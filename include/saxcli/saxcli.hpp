/**
 * Copyright (c) 2024, Adrien Devresse <adev@adev.name>
 *
 * Boost Software License - Version 1.0
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#pragma once

#include <array>
#include <cstddef>
#include <functional>
#include <initializer_list>
#include <memory>
#include <string>
#include <string_view>
#include <type_traits>
#include <utility>
#include <span>

#include <tl/expected.hpp>

namespace saxcli {

namespace intern {

// non-copyable class for convenience
class non_copyable{
public:
  non_copyable() = default;  
private:
  non_copyable(const non_copyable&) = delete;
  non_copyable(non_copyable&&) = delete;
  non_copyable& operator=(const non_copyable&) = delete;
  non_copyable& operator=(non_copyable&&) = delete;

};

enum class parsing_code{
  valid = 0x00,
  invalid_type = 0x01
};


inline void call_if_valid(const std::function<void (std::string_view)> & callback, std::string_view sv){
  if(callback){
    callback(sv);
  }
}


} // intern

namespace backport{
  template<typename T, typename E>
  using expected = tl::expected<T, E>;

} // backport


// concepts
template<typename T>
concept SVCallableConcept = requires(T t, std::string_view sv) {
    { t(sv) } -> std::convertible_to<void>;
};

/// @brief errcode 
enum class errcode{
  unknown = 0x00,
  invalid_progname = 0x01,
};


// succesful argument parsing
struct success{};
// error during parsing
struct error{
  errcode code;
  std::string message;
};

using result = backport::expected<success, error>;


class option_handler : private intern::non_copyable{
public:
  template<SVCallableConcept Callable>
  inline option_handler(std::string_view name, const Callable & callback, std::string_view description) : name_(name), 
  
  callback_([&callback](std::string_view sv) -> intern::parsing_code{
    callback(sv);
    return intern::parsing_code::valid;
  }), description_(description){}

private:  
  std::string_view name_;
  std::function<intern::parsing_code (std::string_view sv)> callback_;
  std::string_view description_;
};

struct subcommand_handler{};

struct positional_handler{};


class args_handler: public intern::non_copyable{
public:
  inline args_handler(){}
  args_handler(const args_handler&) = delete;
  args_handler(args_handler&&) = delete;

  constexpr void options(std::initializer_list<option_handler> list_options){
    options_ = std::span<const option_handler>(list_options.begin(), list_options.end());
  }

  template<SVCallableConcept Callable> 
  constexpr void prog_name(const Callable & cb){
    prog_name_ = cb;
  }

private:
  std::string_view desc_;
  std::function<void (std::string_view)> prog_name_;
  std::span<const option_handler> options_;
  std::span<const positional_handler> positionals_;
  std::span<const subcommand_handler> subcommands_;

  friend result parse_args(const args_handler & args, int argc,
                              char **argv);

};


// CLI argument parser
result parse_args(const args_handler & args, int argc,
                              char **argv){

  if (argc < 1 || std::string_view(argv[0]).size() == 0) {
    return tl::unexpected(error{
        .code = errcode::invalid_progname,
        .message = "argc shall be >= 1"});
  }

  if(args.prog_name_){
    args.prog_name_(std::string_view(argv[0]));
  }

  bool end_of_options = false;
  for(int i = 1; i < argc; ++i){
    const std::string_view current_arg(argv[i]);


    if(current_arg == "--"){
      end_of_options = true;
      continue;
    }

    if(end_of_options == false){
      // lets check long args
      if(current_arg.size() >= 3 && current_arg[0] == '-'){
        std::size_t number_of_dash = 1;
        // todo
      }
    }



  }
  
  return success{};
}

} // namespace saxcli
